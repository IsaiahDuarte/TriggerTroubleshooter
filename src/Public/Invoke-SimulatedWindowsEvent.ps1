function Invoke-SimulatedWindowsEvent {
    <#
    .SYNOPSIS
        Invokes a simulated Windows event trigger on a specified computer.
    
    .DESCRIPTION
        This function retrieves computer and trigger details, creates a temporary WindowsEvent trigger,
        invokes the corresponding action, waits for the trigger to fire, tests the trigger, and cleans up.
    
    .PARAMETER TriggerName
        The name of the trigger to use.
    
    .PARAMETER ComputerName
        The name of the computer on which to invoke the event.
    
    .EXAMPLE
        Invoke-SimulatedWindowsEvent -TriggerName "MyWinEvent" -ComputerName "COMP01"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $TriggerName,
      
        [Parameter(Mandatory = $true)]
        [string] $ComputerName
    )
    
    # Initialize external variables used in Finally
    $newTrigger = $null
    $newTriggerName = $null
    
    try {
        Write-Verbose "Querying computer '$ComputerName' details."
        $computerQuery = Invoke-CUQuery -Table Computers -Where "sName='$($ComputerName.ToUpper())'" -Fields sName, Status, FolderPath
        $computer = $computerQuery.Data
        if (-not $computer) { throw "Unable to find computer '$ComputerName'." }
    
        Write-Verbose "Computer found. Checking Status..."
        if ($computer.Status -ne "Ready") { throw "Status is not 'Ready' for '$ComputerName'. Current status: $($computer.Status)" }
    
        Write-Verbose "Retrieving trigger '$TriggerName'."
        $trigger = Get-Trigger -Name $TriggerName
        if (-not $trigger) {
            Write-Warning "Trigger '$TriggerName' not found."
            return
        }
    
        if ($trigger.TriggerType -ne "Windows Event") {
            Write-Warning "Trigger '$TriggerName' is of type '$($trigger.TriggerType)', not a Windows Event trigger."
            throw "Invalid trigger type."
        }
    
        Write-Verbose "Querying Root Folder details."
        $rootFolderResult = Invoke-CUQuery -Table Folders -Where "FolderType=4" -Fields Path
        $rootFolder = $rootFolderResult.Data
        if (-not $rootFolder) { throw "Unable to find Root Folder for organization." }
    
        Write-Verbose "Retrieving trigger details."
        $details = Get-CUTriggerDetails -TriggerId $trigger.ID
        $rootNode = [ControlUp.PowerShell.Common.Contract.Triggers.TriggerFilterNode]::New()
        $rootNode.ChildNodes = $details.FilterNodes
    
        Write-Verbose "Getting matching Windows event."
        $node = Get-MatchingWindowsEvent -RootNode $rootNode
    
        $newTriggerName = "TT-Simulated-WindowsEvent-" + [guid]::NewGuid().ToString()
        Write-Verbose "Preparing data for new trigger '$newTriggerName'."
        $newTriggerSplat = @{
            TriggerName        = $newTriggerName
            Description        = "Generated by TriggerTroubleshooter"
            TriggerType        = "WindowsEvent"
            FilterNodes        = $node.Node.ChildNodes
            IncidentScheduleId = "All days"
            Scope              = @{
                ExcludedFolders = $rootFolder.Path
                IncludedFolders = $computer.FolderPath
            }
        }
    
        # Account for known module version bug (resolved in later releases)
        if ((Get-Module -Name ControlUp.PowerShell.User).Version.Minor -eq 0) {
            Write-Verbose "Applying workaround for module bug."
            $newTriggerSplat.ComputerDownProperties = @{}
        }
    
        Write-Verbose "Creating new trigger."
        $newTrigger = Add-CUTrigger @newTriggerSplat
        Wait-ForTrigger -TriggerName $newTriggerName -ShouldExist | Out-Null
    
        Write-Verbose "Retrieving available action for trigger troubleshooting."
        $Action = Get-CUAvailableActions -DisplayName "Trigger Troubleshooter - Simulated Test"
        
        if($null -eq $Action) {
            Write-Warning "Unable to find Trigger Troubleshooter - Simulated Test script action"
            throw "Missing Script Action"
        }

        # Map event entry types.
        $entryTypeMapping = @{ 1 = "Error"; 2 = "Information"; 3 = "Warning" }

        $Params = @{
            arg_0 = $node.Event.Log
            arg_1 = $node.Event.Source
            arg_2 = $node.Event.EventID
            arg_3 = $entryTypeMapping[$node.Event.EntryType]
            arg_4 = $node.Event.Message
        } | ConvertTo-Json
    
        Write-Verbose "Invoking action '$($Action.DisplayName)'."
        $actionResult = Invoke-CUAction -ActionId $Action.ID -Table $Action.Table -RecordsGuids $computer.Key -UserInput $Params
    
        if ($actionResult.Result -eq 'Error') {
            Write-Error $actionResult.ErrorMessage
            throw "Action invocation failed."
        }
    
        Write-Verbose "Waiting for trigger '$newTriggerName' to fire."
        $didTriggerFire = Wait-ForTriggerToFire -TriggerName $newTriggerName
    
        Write-Verbose "Testing trigger '$newTriggerName'."
        $result = Test-Trigger -Name $newTriggerName -AllRecords
    
        return [pscustomobject] @{
            TriggerFired = $didTriggerFire
            Result       = $result
        }
    }
    catch {
        Write-Error "Error in Invoke-SimulatedWindowsEvent: $($_.Exception.Message)"
        throw
    }
    finally {
        if ($newTrigger -and $newTrigger.TriggerId) {
            Write-Verbose "Removing trigger '$newTriggerName'."
            Remove-CUTrigger -TriggerId $newTrigger.TriggerId | Out-Null
            Wait-ForTrigger -TriggerName $newTriggerName | Out-Null
        }
    }
}