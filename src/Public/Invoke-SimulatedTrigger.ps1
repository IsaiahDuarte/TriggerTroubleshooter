function Invoke-SimulatedTrigger {
    <#
    .SYNOPSIS
        Invokes a simulated trigger of a given type (CPU, Memory, or Windows Event).
    .DESCRIPTION
        Creates a temporary trigger based on an existing reference, invokes a matching test action,
        waits for the new trigger to fire, tests the trigger, and cleans up.
    .PARAMETER ComputerName
    .PARAMETER TriggerName
    .PARAMETER ConditionType
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $ComputerName,

        [Parameter(Mandatory = $true)]
        [string] $TriggerName,

        [Parameter(Mandatory = $true)]
        [ValidateSet("CPU", "Memory", "WindowsEvent", "LogicalDisk")]
        [string] $ConditionType
    )

    $newTriggerName = $null
    try {
        Write-TriggerTroubleshooterLog "Checking computer status."
        $computer = Get-ComputerStatus -ComputerName $ComputerName
        if ($computer.Status -ne "Ready") {
            throw "Status is not 'Ready' for '$ComputerName'. Current: $($computer.Status)"
        }

        Write-TriggerTroubleshooterLog "Retrieving trigger '$TriggerName'."
        $trigger = Get-Trigger -Name $TriggerName -Fields @("Name", "Id", "TriggerType", "TableName")
        if (-not $trigger) {
            Write-Warning "Trigger '$TriggerName' not found."
            return
        }

        switch ($ConditionType) {
            { ("CPU", "Memory") -contains $_ } {
                if ($trigger.TriggerType -ne "Machine Stress" -or $trigger.TableName -ne "Computers") {
                    Write-Warning "Trigger '$TriggerName' is not an Advanced Machine Trigger."
                    throw "Invalid Trigger Type"
                }
            }
            "WindowsEvent" {
                if ($trigger.TriggerType -ne "Windows Event") {
                    Write-Warning "Trigger '$TriggerName' is not a Windows Event Trigger."
                    throw "Invalid Trigger Type"
                }
            }
        }

        Write-TriggerTroubleshooterLog "Querying root folder details."
        $rootFolder = (Invoke-CUQuery -Table Folders -Where "FolderType=4" -Fields Path).Data
        if (-not $rootFolder) { throw "Unable to find Root Folder." }

        Write-TriggerTroubleshooterLog "Retrieving trigger details."
        $details = Get-CUTriggerDetails -TriggerId $trigger.ID
        $rootNode = [ControlUp.PowerShell.Common.Contract.Triggers.TriggerFilterNode]::New()
        $rootNode.ChildNodes = $details.FilterNodes

        Write-TriggerTroubleshooterLog "Finding matching condition."
        switch ($ConditionType) {
            "CPU" { $node = Get-MatchingCPUCondition -RootNode $rootNode; $newTriggerName = "TT-Simulated-CPUUsage-" + [guid]::NewGuid() }
            "Memory" { $node = Get-MatchingMemoryCondition -RootNode $rootNode; $newTriggerName = "TT-Simulated-MemoryUsage-" + [guid]::NewGuid() }
            "WindowsEvent" { $node = Get-MatchingWindowsEvent -RootNode $rootNode; $newTriggerName = "TT-Simulated-WindowsEvent-" + [guid]::NewGuid() }
            "LogicalDisk" { $node = Get-MatchingLogicalDiskCondition -RootNode $rootNode; $newTriggerName = "TT-Simulated-LogicalDisk" + [guid]::NewGuid() }
        }

        Write-TriggerTroubleshooterLog "Preparing new trigger info."
        $newTriggerSplat = @{
            TriggerName        = $newTriggerName
            Description        = "Generated by TriggerTroubleshooter"
            IncidentScheduleId = "All days"
            Scope              = @{
                ExcludedFolders = $rootFolder.Path
                IncludedFolders = $computer.FolderPath
            }
            FilterNodes        = $node.Node.ChildNodes
        }

        if ($ConditionType -in @("CPU", "Memory")) {
            $newTriggerSplat.TriggerType = "Advanced"
            $newTriggerSplat.AdvancedTriggerSettings = @{ TriggerStressRecordType = "Machine" }
        }
        elseif($ConditionType -eq "WindowsEvent") {
            $newTriggerSplat.TriggerType = "WindowsEvent"
            
            # There is an issue with 9.0.5
            if ((Get-Module -Name ControlUp.PowerShell.User).Version.Minor -eq 0) {
                $newTriggerSplat.ComputerDownProperties = @{}
            }
        } elseif($ConditionType -eq "LogicalDisk") {
            $newTriggerSplat.TriggerType = "Advanced"
            $newTriggerSplat.AdvancedTriggerSettings = @{ TriggerStressRecordType = "LogicalDisk" }
        }

        Write-TriggerTroubleshooterLog "Creating new trigger '$newTriggerName'."
        Write-TriggerTroubleshooterLog "$($newTriggerSplat | ConvertTo-Json -Depth 20)"

        $newTrigger = Add-CUTrigger @newTriggerSplat
        Wait-ForTrigger -TriggerName $newTriggerName -ShouldExist | Out-Null

        Write-TriggerTroubleshooterLog "Retrieving action for trigger troubleshooting."
        $action = Get-CUAvailableActions -DisplayName "Trigger Troubleshooter - Simulated Test"
        if (-not $action) {
            Write-Warning "Unable to find Trigger Troubleshooter - Simulated Test script action."
            throw "Missing Script Action"
        }

        Write-TriggerTroubleshooterLog "Preparing action parameters."

        # Timeout waiting for trigger to fire
        $timeout = 30
        switch ($ConditionType) {
            "CPU" {
                $Params = @{ arg_0 = "CPU"; arg_6 = 15 } | ConvertTo-Json
                $timeout = 1
            }
            "Memory" {
                $Params = @{ arg_0 = "Memory"; arg_6 = 6 } | ConvertTo-Json
                $timeout = 1
            }
            "WindowsEvent" {
                $entryTypeMapping = @{ 1 = "Error"; 2 = "Information"; 3 = "Warning" }
                $evData = $node.Data
                $Params = @{
                    arg_0 = "WindowsEvent"
                    arg_1 = $evData.Log
                    arg_2 = $evData.Source
                    arg_3 = $evData.EventID
                    arg_4 = $entryTypeMapping[$evData.EntryType]
                    arg_5 = $evData.Message
                    arg_6 = $timeout
                } | ConvertTo-Json
                $timeout = 30
            }
            "LogicalDisk" {
                $Params = @{ arg_0 = "LogicalDisk"; arg_6 = 10; arg_7 = $node.Data.FreeSpacePercentage } | ConvertTo-Json
                $timeout = 1
            }
        }

        Write-TriggerTroubleshooterLog "Invoking action '$($action.Title)'."
        Write-TriggerTroubleshooterLog "UserInput: $Params"
        Write-TriggerTroubleshooterLog "Executing $($action.name) ($($action.id)) on $($computer.Name) ($($computer.Key))"
        $actionResult = Invoke-CUAction -ActionId $action.ID -Table $action.Table -RecordsGuids $computer.Key -UserInput $Params
        if ($actionResult.Result -eq 'Error') {
            Write-Error $actionResult.ErrorMessage
            throw "Action invocation failed."
        }

        Write-TriggerTroubleshooterLog "Waiting for the new trigger to fire."
        $didTriggerFire = Wait-ForTriggerToFire -TriggerName $newTriggerName -Timeout $timeout

        Write-TriggerTroubleshooterLog "Trigger Fired: $didTriggerFire"
        return [pscustomobject] @{
            TriggerFired = $didTriggerFire
        }
    }
    catch {
        Write-TriggerTroubleshooterLog "ERROR: $($_.Exception.Message)"
        Write-Error "Error in Invoke-SimulatedTrigger: $($_.Exception.Message)"
        throw
    }
    finally {
        if ($newTrigger -and $newTrigger.TriggerId) {
            Write-TriggerTroubleshooterLog "Removing trigger '$newTriggerName'."
            Remove-CUTrigger -TriggerId $newTrigger.TriggerId | Out-Null
            Wait-ForTrigger -TriggerName $newTriggerName | Out-Null
        }
    }
}